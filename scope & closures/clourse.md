## 闭包作用域

我们已经明了作用域的作用机制，接下来就是重中之重：闭包。它看上去可能很是神奇，现在我们就一起来揭开它神秘的面纱:boom:

### 申明

对很多有经验的开发者而言，他们可能并没有真正的理解闭包，理解闭包看起来像是通往顶级的打怪升级，必须而且不那么简单，回想起自己(....作者巴拉巴拉一大堆），

*闭包无所不在，就想空气一般*

闭包其实是依赖词法作用域自然而然出现的，甚至都不需要刻意“创建”一个闭包并利用它，而是在代码编写过程中，它就这么出现了，我们只是缺少一双慧眼来识别它而已，所以这篇文章最重要的点是：

*闭包无所不在，明确识别它们*

### Nitty Gritty

好了，扯了这么多蛋，可以开始正经事情了，先来个普遍的闭包定义：

> 闭包是指函数在其词法作用域外依然能访问它的词法作用域

先上代码为敬：

```js
function foo() {
				var a = 2;
				function bar() {
								console.log( a ); //2
				}
	bar();
}

foo();
```

这跟我们之前提到的作用域嵌套很相似，`bar`能访问到`a`，其实是一个词法作用域的查询规则而已的，那这是一个闭包吗？

额....这算是吧？其实更加精确理解上述代码是：基本的词法作用域查询机制而已，当然这也是闭包的重要规则啦。

这里我们的`bar`函数对`foo`作用域有*封闭*的作用，其实就是说：如果两个作用里都有变量`a`，那么`foo`中的`a`不会被访问到，而是直接访问了`bar`中的变量`a`，其实这是很自然的事情，因为`bar`内嵌于`foo`，根据词法作用域的基本规则，这是必然的嘛！

我们还是把闭包丢到明火中吧！

```js
function foo() {
				var a = 2;
				function bar() {
								console.log( a );
				}
				return bar;
}

var baz = foo();
baz();
```
函数`bar`对`foo`词法作用域有访问权限，这是很自然的事情，但是当我们把它作为一个参数赋值，在这里我们通过`return`来通过`bar`索引返回函数本身。在执行完`foo()`后，我们就把内部函数`bar`赋值给了变量`baz`,紧接着调用它，这自然就是对`bar`的调用嘛，只是用了另外一个不同的标识符而已，函数本身还是那个函数本体。

*函数执行了，但是执行的位置不是它词法作用域中，而是在它词法作用域之外*

根据垃圾回收机制，`foo`函数执行完毕后理应回收一切关于函数`foo`占用的内存，所以，我们应该也是不能访问到`foo`函数作用域中的变量，因为这一次都随风而去了，正是闭包的存在，神奇的事情发生了：

`bar`作用域其实还在使用中，谁使用这个作用域，其实即使它自己。和它定义位置的对`foo`作用域的封闭一样，`bar`依然保持着对它词法作用域的封闭，并且对`bar`而言，在任何时候都能被调用。

`bar`依然保持有对`foo`词法作用域访问的索引，这个索引称为闭包。

所以，当我们执行`baz`时（本质上就是调用了内部函数*bar*)，它理所当然地能访问变量`a`。函数可以在词法作用域之外调用，闭包使得这个函数依然能访问它定义时的作用域。，当然，将函数作为值传递方式不止一种，我们还可以这样：

```js
function foo() {
				var a = 2;
				function baz() {
								console.log( a ); //2
				}
				bar( baz );
}
funtion bar( fn ) {
				fn();
}
```

```js
var fn;
function foo() {
				var a = 2;
				function baz() {
								console.log( a );
				}
				fn = baz; //assign `baz` to global variable
}
function bar() {
				fn(); // look ma, I saw clourse
}
foo();
bar();
```

不管我们通过什么方式把内部函数传递到外部，它都将维护一个索引，指向它定义的位置，无论我们在哪里调用它，闭包就起作用哒:boom::boom::boom:



