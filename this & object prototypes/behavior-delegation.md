## delegation行为

上一章节中，我们强调了[[Prototype]]的一些基础性原理，实现机制等等，也阐述了多年来对它关于“类”或者“继承”的一些误解，它好像一个魔盒一样的帮我们完成一些事情，但是，就学习应用的角度而言，我们应该深入学习它，在这一章里，我们来拉开原型的神秘面纱，从本质上掌握它，从而更好地，更直接多利用原型，这无疑是有利于我们的开发，甚至是代码维护工作的。

[[Prototype]]的机制是：某对象上指向另一对象的索引。

这种关系主要存在于对某对象的某一个属性或方法查询时，但是这个对象本身又没有对应的属性或方法，这种情况下，[[Prototype]]就会站出来帮忙，从我这个楼梯走到你关联的另一个对象，看它那有没有你要的这个属性或方法，假如，在这个对象同样也没有找到，那么它本身的[[Prototype]]也会站出来，来，来，来，从我这个走，到你自己关联的对象上去找找。这些对象间的联系我们就称为原型链。

换句话说，原型链最关键本质的就是对象关联。

## 面向delegation的设计

为了更直接使用[[Prototype]]，首先，我们必须明确，它同面向类设计的差异！建立好这种思维后，我们才能最有效的利用好的[[Prototype]]。

### 类

这里是关于类的一些基本原理，我就自己看看原文了，就不做翻译，因为我也不是很懂，只提最关键的一点：类的实例是复制。

### delegation

假设我们有一系列相同的任务，我们需要对它们模块化，上面我们省略掉了基于类的设计，这里细细学习下基于delegation的设计：

首先，我们定义一个叫`Tasks`的对象，它包含一些常用的方法，它们可以用来delegation to，接着，为每一个任务新建一个对象，它们包含自己的特有的任务或数据等等，同时，通过与`Tasks`对象的关联，我们可以访问到定义在`Tasks`上的那些常用方法：

```js
var Task = {
				setID: function(ID) {
								this.id = ID;
				},
				outputID: function() {
								console.log( this.id );
				}
};

//make XYZ delegation to Task

var XYZ = Object.create( Task );
XYZ.prepareTask = function( ID, Label ) {
				this.setID( ID );
				this.label = Label;
};

XYZ.outputTaskDetails = function() {
				this.output( ID );
				console.log( this.label );
};

```

上述代码中：`Task`和`XYZ`都不是类，它们都仅仅只是一个对象而已，其中`XYZ`通过`Object.create()`至`[[Prototype]]``代理到`Task`对象。

我们可以称这种和传统面向对象的编码为面向关联的编码（这原作者也是脑洞大开），简称(OLOO)，我们真正关心地是`XYZ`对象代理到`Task`。

JavaScript中，[[Prototype]]机制使得对象间建立了联系，这种方式没有面向对象的那些抽象概念，不管你怎么说服自己，只不过是在用复杂的方法来实现一个本来就很自然的功能而已，用咱中国人话说：你这是费力不讨好啊！啊哈哈！

正经点说：

1. `ID`和`Label`都是实实在在存在于代理(`XYZ`和`ABC`)，而不是在`Task`上的。
2. 面向对象设计时，实例常会定义和类相同的函数名，以此可以覆盖类上的方法，OLOO这是相反地，基于代理机制，我们尽可能定义不同方法，这可能没有很明显的好处，但是，代码的维护和可读性就大大地提高了。
3. `this.setID()`，在`XYZ`对象上调用`setID`方法：哟，这个对象上木有，[[Prototype]]意味着要去`Task`看看，哟，还真有呀！这里，根据`this`的调用机制，很明显是绑定到XYZ对象上的（不记得呢？你丫的回去复习复习this绑定规则1234😡)。






